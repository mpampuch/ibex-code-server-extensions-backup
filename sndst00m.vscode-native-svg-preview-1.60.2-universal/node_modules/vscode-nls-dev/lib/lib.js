/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaDataBundler = exports.removePathPrefix = exports.bundle2keyValuePair = exports.createLocalizedMessages = exports.resolveMessageBundle = exports.processFile = exports.PackageJsonMessageBundle = exports.ResolvedJavaScriptMessageBundle = exports.JavaScriptMessageBundle = exports.LocalizeInfo = void 0;
var fs = require("fs");
var path = require("path");
var source_map_1 = require("source-map");
var ts = require("typescript");
var clone = require("clone");
var crypto = require("crypto");
var SingleFileServiceHost = /** @class */ (function () {
    function SingleFileServiceHost(options, filename, contents) {
        var _this = this;
        this.options = options;
        this.filename = filename;
        this.getCompilationSettings = function () { return _this.options; };
        this.getScriptFileNames = function () { return [_this.filename]; };
        this.getScriptVersion = function () { return '1'; };
        this.getScriptSnapshot = function (name) { return name === _this.filename ? _this.file : _this.lib; };
        this.getCurrentDirectory = function () { return ''; };
        this.getDefaultLibFileName = function () { return 'lib.d.ts'; };
        this.file = ts.ScriptSnapshot.fromString(contents);
        this.lib = ts.ScriptSnapshot.fromString('');
    }
    return SingleFileServiceHost;
}());
var LocalizeInfo;
(function (LocalizeInfo) {
    function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
    }
    LocalizeInfo.is = is;
})(LocalizeInfo = exports.LocalizeInfo || (exports.LocalizeInfo = {}));
var JavaScriptMessageBundle;
(function (JavaScriptMessageBundle) {
    function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.messages) && isDefined(candidate.keys);
    }
    JavaScriptMessageBundle.is = is;
})(JavaScriptMessageBundle = exports.JavaScriptMessageBundle || (exports.JavaScriptMessageBundle = {}));
var ResolvedJavaScriptMessageBundle;
(function (ResolvedJavaScriptMessageBundle) {
    function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.keys) && isDefined(candidate.messages) && isDefined(candidate.map);
    }
    ResolvedJavaScriptMessageBundle.is = is;
    function asTranslatedMessages(bundle, translatedMessages, problems) {
        var result = [];
        bundle.keys.forEach(function (key) {
            var translated = translatedMessages ? translatedMessages[key] : undefined;
            if (isUndefined(translated)) {
                if (translatedMessages) {
                    problems.push("No localized message found for key " + key);
                }
                translated = bundle.map[key];
            }
            result.push(translated);
        });
        return result;
    }
    ResolvedJavaScriptMessageBundle.asTranslatedMessages = asTranslatedMessages;
})(ResolvedJavaScriptMessageBundle = exports.ResolvedJavaScriptMessageBundle || (exports.ResolvedJavaScriptMessageBundle = {}));
var PackageJsonMessageBundle;
(function (PackageJsonMessageBundle) {
    function asTranslatedMessages(bundle, translatedMessages, problems) {
        var result = Object.create(null);
        Object.keys(bundle).forEach(function (key) {
            var message = translatedMessages ? translatedMessages[key] : undefined;
            if (isUndefined(message)) {
                if (translatedMessages) {
                    problems.push("No localized message found for key " + key);
                }
                message = bundle[key];
            }
            result[key] = message;
        });
        return result;
    }
    PackageJsonMessageBundle.asTranslatedMessages = asTranslatedMessages;
})(PackageJsonMessageBundle = exports.PackageJsonMessageBundle || (exports.PackageJsonMessageBundle = {}));
var toString = Object.prototype.toString;
function isString(value) {
    return toString.call(value) === '[object String]';
}
function isDefined(value) {
    return typeof value !== 'undefined';
}
function isUndefined(value) {
    return typeof value === 'undefined';
}
var TextModel = /** @class */ (function () {
    function TextModel(contents, rawSourceMap) {
        var _this = this;
        this.rawSourceMap = rawSourceMap;
        var regex = /\r\n|\r|\n/g;
        var index = 0;
        var match;
        this.lines = [];
        while (match = regex.exec(contents)) {
            this.lines.push({ content: contents.substring(index, match.index), ending: match[0], mappings: null });
            index = regex.lastIndex;
        }
        if (contents.length > 0) {
            this.lines.push({ content: contents.substring(index, contents.length), ending: '', mappings: null });
        }
        if (rawSourceMap) {
            var sourceMapConsumer = new source_map_1.SourceMapConsumer(rawSourceMap);
            sourceMapConsumer.eachMapping(function (mapping) {
                // Note that the generatedLine index is one based;
                var line = _this.lines[mapping.generatedLine - 1];
                if (line) {
                    if (!line.mappings) {
                        line.mappings = [];
                    }
                    line.mappings.push(mapping);
                }
            }, null, source_map_1.SourceMapConsumer.GENERATED_ORDER);
        }
    }
    Object.defineProperty(TextModel.prototype, "lineCount", {
        get: function () {
            return this.lines.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Applies patch(es) to the model.
     * Multiple patches must be ordered.
     * Does not support patches spanning multiple lines.
     */
    TextModel.prototype.apply = function (patches) {
        var _this = this;
        if (patches.length === 0) {
            return;
        }
        patches = patches.sort(function (a, b) {
            var lca = a.span.start;
            var lcb = b.span.start;
            return lca.line != lcb.line ? lca.line - lcb.line : lca.character - lcb.character;
        });
        var overlapping = false;
        if (patches.length > 1) {
            var previousSpan = patches[0].span;
            for (var i = 1; i < patches.length; i++) {
                var nextSpan = patches[i].span;
                if (previousSpan.end.line > nextSpan.start.line || (previousSpan.end.line === nextSpan.start.line && previousSpan.end.character >= nextSpan.start.character)) {
                    overlapping = true;
                    break;
                }
            }
        }
        if (overlapping) {
            throw new Error("Overlapping text edits generated.");
        }
        var lastPatch = patches[patches.length - 1];
        var lastLine = this.lines[this.lineCount - 1];
        if (lastPatch.span.end.line > this.lines.length || (lastPatch.span.end.line === this.lineCount && lastPatch.span.end.character > lastLine.content.length)) {
            throw new Error("Patches are outside of the buffer content.");
        }
        var mappingCursor = { line: -1, index: -1 };
        patches.reverse().forEach(function (patch) {
            var startLineNumber = patch.span.start.line;
            var endLineNumber = patch.span.end.line;
            var startLine = _this.lines[startLineNumber];
            var endLine = _this.lines[endLineNumber];
            // Do the textual manipulations.
            startLine.content = [
                startLine.content.substring(0, patch.span.start.character),
                patch.content,
                endLine.content.substring(patch.span.end.character)
            ].join('');
            for (var i = startLineNumber + 1; i <= endLineNumber; i++) {
                _this.lines[i].content = null;
            }
            // Adopt source mapping if available
            if (_this.rawSourceMap) {
                if (startLineNumber === endLineNumber) {
                    if (!mappingCursor || mappingCursor.line !== startLineNumber) {
                        mappingCursor.line = startLineNumber;
                        mappingCursor.index = startLine.mappings ? startLine.mappings.length - 1 : -1;
                    }
                    var delta = patch.content.length - (patch.span.end.character - patch.span.start.character);
                    var mappingItem = null;
                    while ((mappingItem = mappingCursor.index !== -1 ? startLine.mappings[mappingCursor.index] : null) != null
                        && mappingItem.generatedColumn > patch.span.start.character) {
                        if (mappingItem.generatedColumn < patch.span.end.character) {
                            // The patch covers the source mapping. Delete it
                            mappingItem.delete = true;
                        }
                        mappingCursor.index--;
                    }
                    // Record the delta on the first source marker after the patch.
                    if (mappingCursor.index + 1 < startLine.mappings.length) {
                        var mapping = startLine.mappings[mappingCursor.index + 1];
                        mapping.columnDelta = (mapping.columnDelta || 0) + delta;
                    }
                }
                else {
                    var startLineMappings = startLine.mappings;
                    if (startLineMappings) {
                        for (var i = startLineMappings.length - 1; i >= 0 && startLineMappings[i].generatedColumn > patch.span.start.character; i--) {
                            startLineMappings[i].delete = true;
                        }
                    }
                    for (var i = startLineNumber + 1; i < endLineNumber; i++) {
                        var line = _this.lines[i];
                        if (line.mappings) {
                            line.mappings.forEach(function (mapping) { return mapping.delete = true; });
                        }
                    }
                    var endLineMappins = endLine.mappings;
                    if (endLineMappins) {
                        var lineDelta = startLineNumber - endLineNumber;
                        var index = 0;
                        for (; index < endLineMappins.length; index++) {
                            var mapping = endLineMappins[index];
                            if (mapping.generatedColumn < patch.span.end.character) {
                                mapping.delete = true;
                            }
                            else {
                                break;
                            }
                        }
                        if (index < endLineMappins.length) {
                            var mapping = endLineMappins[index];
                            mapping.lineDelta = lineDelta;
                            mapping.columnDelta = (patch.span.start.character - patch.span.end.character) + patch.content.length;
                        }
                    }
                }
            }
        });
    };
    TextModel.prototype.generateSourceMap = function () {
        if (!this.rawSourceMap) {
            return undefined;
        }
        var sourceMapGenerator = new source_map_1.SourceMapGenerator({ sourceRoot: this.rawSourceMap.sourceRoot });
        var lineDelta = 0;
        this.lines.forEach(function (line) {
            var mappings = line.mappings;
            var columnDelta = 0;
            if (mappings) {
                mappings.forEach(function (mapping) {
                    lineDelta = (mapping.lineDelta || 0) + lineDelta;
                    columnDelta = (mapping.columnDelta || 0) + columnDelta;
                    if (mapping.delete) {
                        return;
                    }
                    sourceMapGenerator.addMapping({
                        source: mapping.source,
                        name: mapping.name,
                        original: { line: mapping.originalLine, column: mapping.originalColumn },
                        generated: { line: mapping.generatedLine + lineDelta, column: mapping.generatedColumn + columnDelta }
                    });
                });
            }
        });
        return sourceMapGenerator.toString();
    };
    TextModel.prototype.toString = function () {
        var count = this.lineCount;
        var buffer = [];
        for (var i = 0; i < count; i++) {
            var line = this.lines[i];
            if (line.content) {
                buffer.push(line.content + line.ending);
            }
        }
        return buffer.join('');
    };
    return TextModel;
}());
function analyze(contents, relativeFilename, options) {
    if (options === void 0) { options = {}; }
    var vscodeRegExp = /^\s*(["'])vscode-nls\1\s*$/;
    var CollectStepResult;
    (function (CollectStepResult) {
        CollectStepResult[CollectStepResult["Yes"] = 0] = "Yes";
        CollectStepResult[CollectStepResult["YesAndRecurse"] = 1] = "YesAndRecurse";
        CollectStepResult[CollectStepResult["No"] = 2] = "No";
        CollectStepResult[CollectStepResult["NoAndRecurse"] = 3] = "NoAndRecurse";
    })(CollectStepResult || (CollectStepResult = {}));
    function collect(node, fn) {
        var result = [];
        function loop(node) {
            var stepResult = fn(node);
            if (stepResult === CollectStepResult.Yes || stepResult === CollectStepResult.YesAndRecurse) {
                result.push(node);
            }
            if (stepResult === CollectStepResult.YesAndRecurse || stepResult === CollectStepResult.NoAndRecurse) {
                ts.forEachChild(node, loop);
            }
        }
        loop(node);
        return result;
    }
    function isImportNode(node) {
        if (ts.isImportDeclaration(node)) {
            return ts.isStringLiteralLike(node.moduleSpecifier) && vscodeRegExp.test(node.moduleSpecifier.getText());
        }
        if (ts.isImportEqualsDeclaration(node)) {
            return ts.isExternalModuleReference(node.moduleReference)
                && ts.isStringLiteralLike(node.moduleReference.expression)
                && vscodeRegExp.test(node.moduleReference.expression.getText());
        }
    }
    function isRequireImport(node) {
        if (!ts.isCallExpression(node)) {
            return false;
        }
        if (node.expression.getText() !== 'require' || !node.arguments || node.arguments.length !== 1) {
            return false;
        }
        var argument = node.arguments[0];
        return ts.isStringLiteralLike(argument) && vscodeRegExp.test(argument.getText());
    }
    function findClosestNode(node, textSpan) {
        var textSpanEnd = textSpan.start + textSpan.length;
        function loop(node) {
            var length = node.end - node.pos;
            if (node.pos === textSpan.start && length === textSpan.length) {
                return node;
            }
            if (node.pos <= textSpan.start && textSpanEnd <= node.end) {
                var candidadate = ts.forEachChild(node, loop);
                return candidadate || node;
            }
        }
        return loop(node);
    }
    var unescapeMap = {
        '\'': '\'',
        '"': '"',
        '\\': '\\',
        'n': '\n',
        'r': '\r',
        't': '\t',
        'b': '\b',
        'f': '\f'
    };
    function unescapeString(str) {
        var result = [];
        for (var i = 0; i < str.length; i++) {
            var ch = str.charAt(i);
            if (ch === '\\') {
                if (i + 1 < str.length) {
                    var replace = unescapeMap[str.charAt(i + 1)];
                    if (isDefined(replace)) {
                        result.push(replace);
                        i++;
                        continue;
                    }
                }
            }
            result.push(ch);
        }
        return result.join('');
    }
    options = clone(options, false);
    options.noResolve = true;
    options.allowJs = true;
    var filename = 'file.js';
    var serviceHost = new SingleFileServiceHost(options, filename, contents);
    var service = ts.createLanguageService(serviceHost);
    var sourceFile = service.getProgram().getSourceFile(filename);
    var patches = [];
    var errors = [];
    var bundle = { messages: [], keys: [] };
    // all imports
    var imports = collect(sourceFile, function (n) { return isRequireImport(n) || isImportNode(n) ? CollectStepResult.YesAndRecurse : CollectStepResult.NoAndRecurse; });
    var nlsReferences = imports.reduce(function (memo, node) {
        var _a;
        var references = [];
        if (ts.isCallExpression(node)) {
            var parent = node.parent;
            if (ts.isCallExpression(parent) && ts.isIdentifier(parent.expression) && parent.expression.text === '__importStar') {
                parent = node.parent.parent;
            }
            if (ts.isVariableDeclaration(parent)) {
                references = service.getReferencesAtPosition(filename, parent.name.pos + 1);
            }
        }
        else if (ts.isImportDeclaration(node)) {
            if (ts.isNamespaceImport((_a = node.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings)) {
                references = service.getReferencesAtPosition(filename, node.importClause.namedBindings.pos);
            }
        }
        else if (ts.isImportEqualsDeclaration(node)) {
            references = service.getReferencesAtPosition(filename, node.name.pos);
        }
        references.forEach(function (reference) {
            if (!reference.isWriteAccess) {
                var node_1 = findClosestNode(sourceFile, reference.textSpan);
                memo.push(node_1);
            }
        });
        return memo;
    }, []);
    var loadCalls = nlsReferences.reduce(function (memo, node) {
        // We are looking for nls.loadMessageBundle || nls.config. In the AST
        // this is Indetifier -> PropertyAccess -> CallExpression.
        if (!ts.isIdentifier(node) || !ts.isPropertyAccessExpression(node.parent) || !ts.isCallExpression(node.parent.parent)) {
            return memo;
        }
        var callExpression = node.parent.parent;
        var expression = callExpression.expression;
        if (ts.isPropertyAccessExpression(expression)) {
            if (expression.name.text === 'loadMessageBundle') {
                // We have a load call like nls.loadMessageBundle();
                memo.push(callExpression);
            }
            else if (expression.name.text === 'config') {
                // We have a load call like nls.config({...})();
                var parent = callExpression.parent;
                if (ts.isCallExpression(parent) && parent.expression === callExpression) {
                    memo.push(parent);
                }
            }
        }
        return memo;
    }, []);
    var localizeCalls = loadCalls.reduce(function (memo, loadCall) {
        var parent = loadCall.parent;
        if (ts.isCallExpression(parent)) {
            // We have something like nls.config({...})()('key', 'message');
            memo.push(parent);
        }
        else if (ts.isVariableDeclaration(parent)) {
            // We have something like var localize = nls.config({...})();
            service.getReferencesAtPosition(filename, parent.name.pos + 1).forEach(function (reference) {
                if (!reference.isWriteAccess) {
                    var node = findClosestNode(sourceFile, reference.textSpan);
                    if (ts.isIdentifier(node)) {
                        var parent_1 = node.parent;
                        if (ts.isCallExpression(parent_1) && parent_1.arguments.length >= 2) {
                            memo.push(parent_1);
                        }
                        else {
                            var position = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);
                            errors.push("(" + (position.line + 1) + "," + (position.character + 1) + "): localize function (bound to " + node.text + ") used in an unusual way.");
                        }
                    }
                }
            });
        }
        return memo;
    }, []);
    loadCalls.reduce(function (memo, loadCall) {
        if (loadCall.arguments.length === 0) {
            var args = loadCall.arguments;
            patches.push({
                span: { start: ts.getLineAndCharacterOfPosition(sourceFile, args.pos), end: ts.getLineAndCharacterOfPosition(sourceFile, args.end) },
                content: relativeFilename ? "require('path').join(__dirname, '" + relativeFilename.replace(/\\/g, '\\\\') + "')" : '__filename',
            });
        }
        return memo;
    }, patches);
    var messageIndex = 0;
    localizeCalls.reduce(function (memo, localizeCall) {
        var firstArg = localizeCall.arguments[0];
        var secondArg = localizeCall.arguments[1];
        var key = null;
        var message = null;
        var comment = [];
        var text = null;
        if (ts.isStringLiteralLike(firstArg)) {
            text = firstArg.getText();
            key = text.substr(1, text.length - 2);
        }
        else if (ts.isObjectLiteralExpression(firstArg)) {
            for (var i = 0; i < firstArg.properties.length; i++) {
                var property = firstArg.properties[i];
                if (ts.isPropertyAssignment(property)) {
                    var name = property.name.getText();
                    if (name === 'key') {
                        var initializer = property.initializer;
                        if (ts.isStringLiteralLike(initializer)) {
                            text = initializer.getText();
                            key = text.substr(1, text.length - 2);
                        }
                    }
                    else if (name === 'comment') {
                        var initializer = property.initializer;
                        if (ts.isArrayLiteralExpression(initializer)) {
                            initializer.elements.forEach(function (element) {
                                if (ts.isStringLiteralLike(element)) {
                                    text = element.getText();
                                    comment.push(text.substr(1, text.length - 2));
                                }
                            });
                        }
                    }
                }
            }
        }
        if (!key) {
            var position = ts.getLineAndCharacterOfPosition(sourceFile, firstArg.pos);
            errors.push("(" + (position.line + 1) + "," + (position.character + 1) + "): first argument of a localize call must either be a string literal or an object literal of type LocalizeInfo.");
            return memo;
        }
        if (ts.isStringLiteralLike(secondArg)) {
            var text_1 = secondArg.getText();
            message = text_1.substr(1, text_1.length - 2);
        }
        if (!message) {
            var position = ts.getLineAndCharacterOfPosition(sourceFile, secondArg.pos);
            errors.push("(" + (position.line + 1) + "," + (position.character + 1) + "): second argument of a localize call must be a string literal.");
            return memo;
        }
        message = unescapeString(message);
        memo.patches.push({
            span: { start: ts.getLineAndCharacterOfPosition(sourceFile, firstArg.pos + firstArg.getLeadingTriviaWidth()), end: ts.getLineAndCharacterOfPosition(sourceFile, firstArg.end) },
            content: messageIndex.toString()
        });
        memo.patches.push({
            span: { start: ts.getLineAndCharacterOfPosition(sourceFile, secondArg.pos + secondArg.getLeadingTriviaWidth()), end: ts.getLineAndCharacterOfPosition(sourceFile, secondArg.end) },
            content: 'null'
        });
        bundle.messages.push(message);
        if (comment.length > 0) {
            bundle.keys.push({
                key: key,
                comment: comment
            });
        }
        else {
            bundle.keys.push(key);
        }
        messageIndex++;
        return memo;
    }, { patches: patches });
    return {
        patches: patches,
        errors: errors,
        bundle: bundle
    };
}
function processFile(contents, relativeFileName, sourceMap) {
    var analysisResult = analyze(contents, relativeFileName);
    if (analysisResult.patches.length === 0) {
        return {
            contents: undefined,
            sourceMap: undefined,
            bundle: undefined,
            errors: analysisResult.errors
        };
    }
    var rawSourceMap = undefined;
    if (isString(sourceMap)) {
        try {
            rawSourceMap = JSON.parse(sourceMap);
        }
        catch (e) {
        }
    }
    else if (sourceMap) {
        rawSourceMap = sourceMap;
    }
    var textModel = new TextModel(contents, rawSourceMap);
    textModel.apply(analysisResult.patches);
    return {
        contents: textModel.toString(),
        sourceMap: textModel.generateSourceMap(),
        bundle: analysisResult.bundle,
        errors: analysisResult.errors
    };
}
exports.processFile = processFile;
function stripComments(content) {
    /**
    * First capturing group matches double quoted string
    * Second matches single quotes string
    * Third matches block comments
    * Fourth matches line comments
    */
    var regexp = /("(?:[^\\\"]*(?:\\.)?)*")|('(?:[^\\\']*(?:\\.)?)*')|(\/\*(?:\r?\n|.)*?\*\/)|(\/{2,}.*?(?:(?:\r?\n)|$))/g;
    var result = content.replace(regexp, function (match, m1, m2, m3, m4) {
        // Only one of m1, m2, m3, m4 matches
        if (m3) {
            // A block comment. Replace with nothing
            return '';
        }
        else if (m4) {
            // A line comment. If it ends in \r?\n then keep it.
            var length = m4.length;
            if (length > 2 && m4[length - 1] === '\n') {
                return m4[length - 2] === '\r' ? '\r\n' : '\n';
            }
            else {
                return '';
            }
        }
        else {
            // We match a string
            return match;
        }
    });
    return result;
}
;
function resolveMessageBundle(bundle) {
    if (JavaScriptMessageBundle.is(bundle)) {
        if (bundle.messages.length !== bundle.keys.length) {
            return null;
        }
        var keys_1 = [];
        var map_1 = Object.create(null);
        bundle.keys.forEach(function (key, index) {
            var resolvedKey = isString(key) ? key : key.key;
            keys_1.push(resolvedKey);
            map_1[resolvedKey] = bundle.messages[index];
        });
        return { messages: bundle.messages, keys: keys_1, map: map_1 };
    }
    else {
        return bundle;
    }
}
exports.resolveMessageBundle = resolveMessageBundle;
function createLocalizedMessages(filename, bundle, languageFolderName, i18nBaseDir, baseDir) {
    var problems = [];
    var i18nFile = (baseDir
        ? path.join(i18nBaseDir, languageFolderName, baseDir, filename)
        : path.join(i18nBaseDir, languageFolderName, filename)) + '.i18n.json';
    var messages;
    var bundleLength = ResolvedJavaScriptMessageBundle.is(bundle) ? bundle.keys.length : Object.keys(bundle).length;
    if (fs.existsSync(i18nFile)) {
        var content = stripComments(fs.readFileSync(i18nFile, 'utf8'));
        messages = JSON.parse(content);
        if (Object.keys(messages).length === 0) {
            if (bundleLength > 0) {
                problems.push("Message file " + i18nFile.substr(i18nBaseDir.length + 1) + " is empty. Missing messages: " + bundleLength);
            }
            messages = undefined;
        }
    }
    else {
        if (bundleLength > 0) {
            problems.push("Message file " + i18nFile.substr(i18nBaseDir.length + 1) + " not found. Missing messages: " + bundleLength);
        }
    }
    var translatedMessages;
    if (ResolvedJavaScriptMessageBundle.is(bundle)) {
        translatedMessages = ResolvedJavaScriptMessageBundle.asTranslatedMessages(bundle, messages, problems);
    }
    else {
        translatedMessages = PackageJsonMessageBundle.asTranslatedMessages(bundle, messages, problems);
    }
    if (problems.length > 0) {
        problems.unshift("Generating localized messages for '" + languageFolderName + "' resulted in the following problems:", '');
        problems.push('', '');
    }
    return { messages: translatedMessages, problems: problems };
}
exports.createLocalizedMessages = createLocalizedMessages;
function bundle2keyValuePair(bundle, commentSeparator) {
    if (commentSeparator === void 0) { commentSeparator = undefined; }
    var result = Object.create(null);
    for (var i = 0; i < bundle.messages.length; ++i) {
        var key = void 0;
        var comments = void 0;
        var message = bundle.messages[i];
        var keyInfo = bundle.keys[i];
        if (LocalizeInfo.is(keyInfo)) {
            key = keyInfo.key;
            comments = keyInfo.comment;
        }
        else {
            key = keyInfo;
        }
        if (key in result) {
            throw new Error("The following key is duplicated: \"" + key + "\". Please use unique keys.");
        }
        result[key] = bundle.messages[i];
        if (comments) {
            if (commentSeparator) {
                result["_" + key + ".comments"] = comments.join(commentSeparator);
            }
            else {
                result["_" + key + ".comments"] = comments;
            }
        }
    }
    return result;
}
exports.bundle2keyValuePair = bundle2keyValuePair;
function removePathPrefix(path, prefix) {
    if (!prefix) {
        return path;
    }
    if (!path.startsWith(prefix)) {
        return path;
    }
    var ch = prefix.charAt(prefix.length - 1);
    if (ch === '/' || ch === '\\') {
        return path.substr(prefix.length);
    }
    else {
        return path.substr(prefix.length + 1);
    }
}
exports.removePathPrefix = removePathPrefix;
var MetaDataBundler = /** @class */ (function () {
    function MetaDataBundler(id, outDir) {
        this.id = id;
        this.outDir = outDir;
        this.content = Object.create(null);
    }
    Object.defineProperty(MetaDataBundler.prototype, "size", {
        get: function () {
            return Object.keys(this.content).length;
        },
        enumerable: false,
        configurable: true
    });
    MetaDataBundler.prototype.add = function (file) {
        this.content[file.filePath.replace(/\\/g, '/')] = { messages: file.messages, keys: file.keys };
    };
    MetaDataBundler.prototype.bundle = function () {
        // We use md5 since we only need a finger print.
        // The actual data is public and put into a file.
        // Since the hash is used as a file name in the file
        // system md5 shortens the name and therfore the path
        // especially under Windows (max path issue).
        var md5 = crypto.createHash('md5');
        var keys = Object.keys(this.content).sort();
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            md5.update(key);
            var entry = this.content[key];
            for (var _a = 0, _b = entry.keys; _a < _b.length; _a++) {
                var keyInfo = _b[_a];
                if (isString(keyInfo)) {
                    md5.update(keyInfo);
                }
                else {
                    md5.update(keyInfo.key);
                }
            }
            for (var _c = 0, _d = entry.messages; _c < _d.length; _c++) {
                var message = _d[_c];
                md5.update(message);
            }
        }
        var hash = md5.digest('hex');
        var header = {
            id: this.id,
            type: "extensionBundle",
            hash: hash,
            outDir: this.outDir
        };
        return [header, this.content];
    };
    return MetaDataBundler;
}());
exports.MetaDataBundler = MetaDataBundler;
//# sourceMappingURL=lib.js.map