#!/usr/bin/env node
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var url = require("url");
var yargs = require("yargs");
var glob = require("glob");
var lib_1 = require("./lib");
var argv = yargs
    .usage('Usage: vscl [options] files')
    .option('outDir', {
    alias: 'o',
    describe: 'The output directory. If not specified the files are overwriten in place.',
    demand: false
})
    .option('rootDir', {
    alias: 'r',
    describe: 'The root directory of the sources. Only honored when outDir is set.',
    demand: false
})
    .option('keepFilenames', {
    describe: 'Inlines filenames when making localization calls. Only honored when rootDir is set.',
    demand: false
})
    .argv;
var hasError = false;
var outDir = argv.outDir ? path.resolve(argv.outDir) : null;
var rootDir = argv.rootDir ? path.resolve(argv.rootDir) : null;
var keepFilenames = Boolean(argv.keepFilenames);
argv._.forEach(function (element) {
    glob(element, function (err, matches) {
        if (err) {
            console.error(err.message);
            hasError = true;
            return;
        }
        matches.forEach(function (file) {
            var resolvedFile = path.resolve(file);
            var contents = fs.readFileSync(resolvedFile, 'utf8');
            var sourceMapFile = null;
            var resolvedSourceMapFile = null;
            var sourceMapContent = undefined;
            var sourceMapMatches = contents.match(/\/\/#\s+sourceMappingURL=(.*)(?:\r?\n|\n|$)/);
            if (sourceMapMatches && sourceMapMatches.length === 2) {
                var sourceMapUrl = url.parse(sourceMapMatches[1]);
                // For now we only support relative pathes
                if (sourceMapUrl.protocol || sourceMapUrl.host) {
                    console.error(file + ": protocol or host based source map URLs are not supported.");
                    hasError = true;
                }
                var pathname = sourceMapUrl.pathname;
                if (path.isAbsolute(pathname)) {
                    resolvedSourceMapFile = pathname;
                }
                else {
                    sourceMapFile = pathname;
                    resolvedSourceMapFile = path.join(path.dirname(file), sourceMapFile);
                }
                if (fs.existsSync(resolvedSourceMapFile)) {
                    sourceMapContent = fs.readFileSync(resolvedSourceMapFile, 'utf8');
                }
            }
            var relativeFilename = keepFilenames && rootDir ? path.relative(rootDir, resolvedFile) : undefined;
            var result = lib_1.processFile(contents, relativeFilename, sourceMapContent);
            if (result.errors && result.errors.length > 0) {
                result.errors.forEach(function (error) { return console.error("" + file + error); });
                hasError = true;
            }
            else {
                var outFile = resolvedFile;
                var sourceMapOutFile = resolvedSourceMapFile;
                if (outDir) {
                    if (rootDir && resolvedFile.substring(0, rootDir.length) === rootDir) {
                        outFile = path.join(outDir, resolvedFile.substring(rootDir.length));
                    }
                    else {
                        outFile = path.join(outDir, file);
                    }
                    if (sourceMapFile) {
                        sourceMapOutFile = path.join(outDir, sourceMapFile);
                    }
                }
                if (result.contents) {
                    var dirname = path.dirname(outFile);
                    if (!fs.existsSync(dirname)) {
                        fs.mkdirSync(path.dirname(outFile));
                    }
                    fs.writeFileSync(outFile, result.contents, { encoding: 'utf8' });
                }
                if (sourceMapOutFile && result.sourceMap) {
                    fs.writeFileSync(sourceMapOutFile, result.sourceMap, { encoding: 'utf8' });
                }
                if (result.bundle) {
                    var extension = path.extname(outFile);
                    var bundlefile = outFile.substr(0, outFile.length - extension.length) + '.nls.json';
                    fs.writeFileSync(bundlefile, JSON.stringify(result.bundle, null, 4), { encoding: 'utf8' });
                }
            }
        });
    });
});
if (hasError) {
    process.exit(1);
}
//# sourceMappingURL=vscl.js.map